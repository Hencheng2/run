<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multi-Language Code Runner</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  <script src="https://unpkg.com/monaco-editor@0.29.1/min/vs/loader.js"></script>
  <style>
    body {
      background-color: #1e1e1e;
      color: #ffffff;
      font-family: 'Inter', sans-serif;
      font-size: 16px;
    }
    .scrollbar-dark::-webkit-scrollbar {
      width: 8px;
    }
    .scrollbar-dark::-webkit-scrollbar-track {
      background: #2d2d2d;
    }
    .scrollbar-dark::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    .scrollbar-dark::-webkit-scrollbar-thumb:hover {
      background: #777;
    }
    .editor-container {
      height: calc(100vh - 8rem);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const languages = [
      { name: 'Python', value: 'python', file: 'main.py' },
      { name: 'JavaScript', value: 'javascript', file: 'main.js' },
      { name: 'C++', value: 'cpp', file: 'main.cpp' },
      { name: 'Java', value: 'java', file: 'Main.java' },
      { name: 'Ruby', value: 'ruby', file: 'main.rb' },
      { name: 'Go', value: 'go', file: 'main.go' }
    ];

    const MonacoEditor = ({ language, code, onChange }) => {
      const editorRef = useRef(null);
      const editorInstanceRef = useRef(null);
      
      useEffect(() => {
        if (!editorRef.current) return;

        require.config({ paths: { 'vs': 'https://unpkg.com/monaco-editor@0.29.1/min/vs' } });
        require(['vs/editor/editor.main'], () => {
          if (editorInstanceRef.current) {
            editorInstanceRef.current.dispose();
          }
          
          editorInstanceRef.current = monaco.editor.create(editorRef.current, {
            value: code,
            language: language,
            theme: 'vs-dark',
            automaticLayout: true,
            minimap: { enabled: false },
            lineNumbers: 'on',
            fontSize: 14,
          });

          editorInstanceRef.current.onDidChangeModelContent(() => {
            onChange(editorInstanceRef.current.getValue());
          });
        });

        return () => {
          if (editorInstanceRef.current) {
            editorInstanceRef.current.dispose();
            editorInstanceRef.current = null;
          }
        };
      }, []);

      useEffect(() => {
        if (editorInstanceRef.current) {
          monaco.editor.setModelLanguage(editorInstanceRef.current.getModel(), language);
        }
      }, [language]);
      
      useEffect(() => {
        if (editorInstanceRef.current && editorInstanceRef.current.getValue() !== code) {
          editorInstanceRef.current.setValue(code);
        }
      }, [code]);

      return <div ref={editorRef} className="w-full h-full"></div>;
    };
    
    // Core App Component
    const App = () => {
      const [currentLanguage, setCurrentLanguage] = useState(languages[0]);
      const [files, setFiles] = useState([]);
      const [activeFile, setActiveFile] = useState('');
      const [output, setOutput] = useState('');
      const [status, setStatus] = useState('Idle');
      const [isExplorerOpen, setIsExplorerOpen] = useState(true);
      const [projectName, setProjectName] = useState('My Project');

      const fileInputRef = useRef(null);
      const zipFileInputRef = useRef(null);

      // Save and Load Project Logic
      const saveProjectToLocal = (projectFiles) => {
        const projectData = {
          files: projectFiles,
          projectName: projectName,
          language: currentLanguage.value,
          activeFile: projectFiles.length > 0 ? projectFiles[0].name : '',
        };
        localStorage.setItem('codeRunnerProject', JSON.stringify(projectData));
      };

      const loadProjectFromLocal = () => {
        try {
          const projectData = JSON.parse(localStorage.getItem('codeRunnerProject'));
          if (projectData) {
            setFiles(projectData.files);
            setProjectName(projectData.projectName);
            const language = languages.find(lang => lang.value === projectData.language);
            setCurrentLanguage(language || languages[0]);
            setActiveFile(projectData.activeFile);
          } else {
            // Initialize with default file
            const initialFile = languages[0].file;
            const initialFiles = [{ name: initialFile, content: '', isDependency: false }];
            setFiles(initialFiles);
            setActiveFile(initialFile);
          }
        } catch (e) {
          console.error("Failed to load project from local storage", e);
          const initialFile = languages[0].file;
          const initialFiles = [{ name: initialFile, content: '', isDependency: false }];
          setFiles(initialFiles);
          setActiveFile(initialFile);
        }
      };

      useEffect(() => {
        loadProjectFromLocal();
      }, []);
      
      useEffect(() => {
        if (files.length > 0) {
          saveProjectToLocal(files);
        }
      }, [files, projectName, currentLanguage, activeFile]);

      const handleLanguageChange = (event) => {
        const newLang = languages.find(lang => lang.value === event.target.value);
        if (newLang) {
          setCurrentLanguage(newLang);
          const defaultFile = newLang.file;
          const existingFile = files.find(f => f.name === defaultFile);
          if (existingFile) {
            setActiveFile(defaultFile);
          } else {
            const newFile = { name: defaultFile, content: '', isDependency: false };
            setFiles([...files, newFile]);
            setActiveFile(defaultFile);
          }
        }
      };

      const handleFileContentChange = (content) => {
        setFiles(files.map(file =>
          file.name === activeFile ? { ...file, content } : file
        ));
      };

      const handleAddFile = () => {
        const fileName = prompt("Enter a new file name:");
        if (fileName && !files.find(f => f.name === fileName)) {
          const newFile = { name: fileName, content: '', isDependency: false };
          setFiles([...files, newFile]);
          setActiveFile(fileName);
        }
      };
      
      const handleDeleteFile = (fileName) => {
        if (files.length === 1) {
          alert("Cannot delete the last file.");
          return;
        }
        if (window.confirm(`Are you sure you want to delete ${fileName}?`)) {
          const updatedFiles = files.filter(f => f.name !== fileName);
          setFiles(updatedFiles);
          if (activeFile === fileName) {
            setActiveFile(updatedFiles[0].name);
          }
        }
      };

      const getActiveFileContent = () => {
        const file = files.find(f => f.name === activeFile);
        return file ? file.content : '';
      };
      
      const getDependencyInstructions = () => {
        switch (currentLanguage.value) {
          case 'python': return 'Upload requirements.txt';
          case 'javascript': return 'Upload package.json';
          default: return '';
        }
      };

      const handleRunCode = async () => {
        setStatus('Running...');
        setOutput('');
        const codeToRun = getActiveFileContent();
        
        try {
          switch (currentLanguage.value) {
            case 'python':
              await runPython(codeToRun);
              break;
            case 'javascript':
              await runJavaScript(codeToRun);
              break;
            case 'cpp':
              await runCpp(codeToRun);
              break;
            case 'java':
              await runJava(codeToRun);
              break;
            default:
              setOutput('Execution not supported for this language yet.');
              setStatus('Idle');
          }
        } catch (e) {
          console.error(e);
          setOutput(`Error: ${e.message}`);
          setStatus('Error');
        }
      };

      const runPython = async (code) => {
        setStatus('Setting up Pyodide...');
        await loadScript('https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js');
        const pyodide = await window.loadPyodide();

        const requirementsFile = files.find(f => f.name === 'requirements.txt');
        if (requirementsFile) {
          setStatus('Installing dependencies...');
          const packages = requirementsFile.content.split('\n').filter(Boolean);
          if (packages.length > 0) {
            try {
              await pyodide.loadPackage(packages);
              setOutput((prev) => prev + `\nDependencies installed successfully.`);
            } catch (e) {
              setOutput((prev) => prev + `\nError installing dependencies: ${e.message}`);
              setStatus('Error');
              return;
            }
          }
        }
        
        setStatus('Executing code...');
        try {
          let outputLog = '';
          pyodide.setStdout({
            batched: (log) => { outputLog += log; }
          });
          await pyodide.runPythonAsync(code);
          setOutput((prev) => prev + `\n${outputLog}`);
          setStatus('Success');
        } catch (e) {
          setOutput((prev) => prev + `\n${e.message}`);
          setStatus('Error');
        }
        setStatus('Idle');
      };

      const runJavaScript = async (code) => {
        try {
          const packageJsonFile = files.find(f => f.name === 'package.json');
          if (packageJsonFile) {
            setStatus('Loading dependencies...');
            const { dependencies } = JSON.parse(packageJsonFile.content);
            if (dependencies) {
              for (const [pkg, version] of Object.entries(dependencies)) {
                const cdnUrl = `https://cdn.jsdelivr.net/npm/${pkg}@${version}`;
                await loadScript(cdnUrl);
                setOutput((prev) => prev + `\nLoaded ${pkg}@${version}`);
              }
            }
          }
          setStatus('Executing code...');
          let outputLog = '';
          const originalConsoleLog = console.log;
          console.log = (...args) => {
            outputLog += args.join(' ') + '\n';
          };
          
          eval(code);
          
          console.log = originalConsoleLog;
          setOutput((prev) => prev + `\n${outputLog}`);
          setStatus('Success');
        } catch (e) {
          setOutput((prev) => prev + `\nError: ${e.message}`);
          setStatus('Error');
        }
        setStatus('Idle');
      };

      // Helper function to load a script dynamically
      const loadScript = (src) => new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
      
      const runCpp = async (code) => {
        setStatus('Setting up WebAssembly runtime (Emscripten)...');
        // This is a placeholder as full C++ compilation in-browser is complex.
        // A simple, pre-compiled C++ compiler library would be needed here.
        // For a full implementation, one would use Emscripten to compile a C++
        // runtime, but a simple solution for this prompt is to use a pre-built
        // service or a simpler WASM binary. Let's use a dummy output.
        setOutput('C++ execution via Emscripten is a complex task for a single-file app. This is a placeholder output.');
        setStatus('Idle');
      };
      
      const runJava = async (code) => {
        setStatus('Setting up WebAssembly runtime (CheerpJ)...');
        // This is a placeholder. Similar to C++, a full CheerpJ setup requires
        // more than a single file. A dummy output is provided.
        setOutput('Java execution via CheerpJ is not fully supported in this single-file app. This is a placeholder.');
        setStatus('Idle');
      };

      const handleUploadFile = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          const content = e.target.result;
          const fileName = file.name;
          
          if (files.find(f => f.name === fileName)) {
            if (window.confirm(`File '${fileName}' already exists. Overwrite?`)) {
              setFiles(files.map(f => f.name === fileName ? { ...f, content } : f));
            }
          } else {
            const newFile = { name: fileName, content, isDependency: false };
            setFiles([...files, newFile]);
            setActiveFile(fileName);
          }
        };
        reader.readAsText(file);
      };

      const handleDownloadProject = async () => {
        const JSZip = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
        const zip = new JSZip.default();
        files.forEach(file => {
          zip.file(file.name, file.content);
        });
        const blob = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${projectName.replace(/\s/g, '-')}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const handleUploadProject = (event) => {
        const file = event.target.files[0];
        if (!file || !file.name.endsWith('.zip')) {
          alert('Please upload a .zip file.');
          return;
        }

        const reader = new FileReader();
        reader.onload = async (e) => {
          const JSZip = await import('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
          const zip = new JSZip.default();
          const contents = await zip.loadAsync(e.target.result);
          
          const newFiles = [];
          for (const fileName in contents.files) {
            if (!contents.files[fileName].dir) {
              const fileContent = await contents.files[fileName].async('string');
              newFiles.push({ name: fileName, content: fileContent, isDependency: false });
            }
          }
          if (newFiles.length > 0) {
            setFiles(newFiles);
            setActiveFile(newFiles[0].name);
            setProjectName(file.name.replace('.zip', ''));
          }
        };
        reader.readAsArrayBuffer(file);
      };
      
      return (
        <div className="flex flex-col h-screen bg-gray-900 text-white overflow-hidden">
          {/* Header */}
          <header className="flex items-center justify-between p-4 bg-gray-800 shadow-md">
            <div className="flex items-center space-x-4">
              <h1 className="text-xl font-bold text-gray-100">Code Runner</h1>
              <input 
                type="text" 
                value={projectName} 
                onChange={(e) => setProjectName(e.target.value)}
                className="bg-gray-700 text-gray-100 px-3 py-1 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <select
                value={currentLanguage.value}
                onChange={handleLanguageChange}
                className="bg-gray-700 text-gray-100 px-3 py-1 rounded-md cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                {languages.map(lang => (
                  <option key={lang.value} value={lang.value}>{lang.name}</option>
                ))}
              </select>
            </div>
            <div className="flex items-center space-x-4">
              <button
                onClick={handleRunCode}
                className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition-colors duration-200"
              >
                Run ▶️
              </button>
              <button
                onClick={handleDownloadProject}
                className="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition-colors duration-200"
              >
                Download Project 📥
              </button>
              <input
                type="file"
                ref={zipFileInputRef}
                onChange={handleUploadProject}
                className="hidden"
                accept=".zip"
              />
              <button
                onClick={() => zipFileInputRef.current.click()}
                className="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md transition-colors duration-200"
              >
                Upload Project 📤
              </button>
            </div>
          </header>

          {/* Main Content */}
          <main className="flex flex-grow editor-container">
            {/* File Explorer Panel */}
            <div
              className={`flex-shrink-0 bg-gray-800 transition-all duration-300 ${isExplorerOpen ? 'w-1/4 max-w-xs' : 'w-0'}`}
            >
              <div className={`p-4 h-full flex flex-col ${isExplorerOpen ? '' : 'hidden'}`}>
                <div className="flex items-center justify-between mb-4">
                  <h2 className="text-lg font-semibold">Files</h2>
                  <button onClick={handleAddFile} className="text-blue-500 hover:text-blue-400 font-bold">+</button>
                </div>
                <ul className="flex-grow overflow-y-auto scrollbar-dark">
                  {files.map(file => (
                    <li
                      key={file.name}
                      onClick={() => setActiveFile(file.name)}
                      className={`flex items-center justify-between p-2 rounded-md cursor-pointer mb-1 transition-colors duration-200 ${
                        activeFile === file.name ? 'bg-gray-700' : 'hover:bg-gray-700'
                      }`}
                    >
                      <span>{file.name}</span>
                      <button onClick={(e) => { e.stopPropagation(); handleDeleteFile(file.name); }} className="text-red-500 hover:text-red-400 text-sm">×</button>
                    </li>
                  ))}
                </ul>
                <div className="mt-4">
                  <input
                    type="file"
                    ref={fileInputRef}
                    onChange={handleUploadFile}
                    className="hidden"
                  />
                  <button
                    onClick={() => fileInputRef.current.click()}
                    className="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 rounded-md transition-colors duration-200"
                  >
                    Upload File
                  </button>
                  {getDependencyInstructions() && (
                    <p className="mt-2 text-sm text-gray-400 text-center">{getDependencyInstructions()}</p>
                  )}
                </div>
              </div>
              <button
                onClick={() => setIsExplorerOpen(!isExplorerOpen)}
                className="absolute top-1/2 -right-4 transform -translate-y-1/2 bg-gray-700 text-white p-2 rounded-r-md transition-transform duration-300 hover:bg-gray-600"
                style={{ zIndex: 10 }}
              >
                {isExplorerOpen ? '◀️' : '▶️'}
              </button>
            </div>

            {/* Editor and Output Panel */}
            <div className="flex-grow flex flex-col min-w-0">
              <div className="w-full flex-grow flex">
                <div className="w-2/3 h-full bg-gray-900 border-r border-gray-700">
                  <MonacoEditor
                    language={currentLanguage.value}
                    code={getActiveFileContent()}
                    onChange={handleFileContentChange}
                  />
                </div>
                <div className="w-1/3 flex flex-col bg-gray-900 border-l border-gray-700">
                  <div className="flex-shrink-0 p-2 bg-gray-800 text-sm font-semibold border-b border-gray-700">
                    Output
                  </div>
                  <pre
                    className="flex-grow p-4 text-sm overflow-auto scrollbar-dark whitespace-pre-wrap"
                    style={{ fontFamily: 'monospace' }}
                  >
                    {output}
                  </pre>
                </div>
              </div>
            </div>
          </main>

          {/* Footer */}
          <footer className="flex items-center justify-between p-2 bg-gray-800 text-sm shadow-md">
            <div className="flex items-center space-x-4">
              <span>Status: <span className="font-semibold">{status}</span></span>
              {status === 'Running...' && <span className="loader-spinner animate-spin">⏳</span>}
            </div>
            <span>Version: 1.0.0</span>
          </footer>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
